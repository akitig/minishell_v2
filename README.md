# minishell

exercise

## STEP 1 - 

入力がターミナルから行われているか判別する
- isatty
  - 入力がターミナルから（FD）行われているか、調べることができる

無限ループでmainをそのまま実行すると、止まらなくなってしまう

- readline
  - 対話型シェルの実装などでプロンプト表示と入力取得のために利用される。
  - 動的に確保されるため、利用後にfreeで開放する必要がある。
  - 1行ずつ入力を受け取れる

対話型の場合

- ```isatty(fileno(stdin))```が1
- ```readline("minishell> ")``` を使ってプロンプトを表示しながら入力を受け付ける

非対話型の場合

- ```isatty(fileno(stdin))```が0
- ```get_next_line```を用いて標準入力から1行ずつ読み込む


# 以下未実装

## 【STEP 2：字句解析 (Lexical Analysis)】

目的:
ユーザーが入力した文字列を、コマンドやリダイレクト、パイプなどの「トークン」に分解する。
主なファイル・関数:
lexer.c
関数 tokenize_bashlike()（およびその後の補助関数）
学習ポイント:
・入力文字列をどのように区切るか（空白、タブ、特殊文字など）
・クォートがある場合の扱い（クォート内は分割しないなど）

## 【STEP 3：クォート除去と環境変数展開 (Expansion)】

目的:
トークンに含まれる余分なクォートを除去し、変数（$VAR や $?）を展開する。
主なファイル・関数:
expansions.c
関数 expand_and_remove_quotes()、内部で expand_dollar() を使用
学習ポイント:
・シングルクォートとダブルクォートの違い
・どの部分で変数展開を行い、どこはリテラルとして扱うか

## 【STEP 4：パース処理 (Parsing)】

目的:
字句解析で得たトークンから、実際に実行すべきコマンドの情報（引数、リダイレクト、パイプの情報など）をまとめたコマンド構造体（t_cmd）を生成する。
主なファイル・関数:
parse.c
関数 parse_line()、内部で tokenize_bashlike() を呼び出し、さらに各トークンの展開後にコマンドリスト（t_cmd リスト）を作成
学習ポイント:
・トークンからコマンドごとの情報をどうまとめるか
・リダイレクト記号やパイプ記号の意味の解釈

## 【STEP 5：リダイレクト処理】

目的:
入力リダイレクト（<）、出力リダイレクト（>）、追記リダイレクト（>>）、ヒアドキュメント（<<）の各処理を実装する。
主なファイル・関数:
redirections.c
関数 handle_redirections() と、その内部で使う do_heredoc()
学習ポイント:
・ファイルディスクリプタの操作（open, dup2, close）
・ヒアドキュメントの実装方法と、シェル独自の仕様（クォートの有無で展開の有無が変わるなど）

## 【STEP 6：組み込みコマンド (Builtin Commands) の実装】

目的:
シェルにおける組み込みコマンド（echo, cd, pwd, export, unset, env, exit など）を実装する。
主なファイル・関数:
builtins.c
各コマンドごとの関数（例：builtin_echo(), builtin_cd(), builtin_exit() など）
学習ポイント:
・各組み込みコマンドがどのようにシェル内で動作するか
・エラー処理や環境変数の更新（特に cd や export など）

## 【STEP 7：環境変数の管理】

目的:
実行環境の変数（env）を内部リストとして管理し、取得、設定、削除の操作を可能にする。
主なファイル・関数:
env_utils.c
関数 envlist_from_environ(), envlist_get_value(), envlist_set_value(), remove_envkey() など
学習ポイント:
・環境変数をリストで管理する方法
・文字列操作と動的メモリ管理

## 【STEP 8：コマンドの実行】

目的:
パース処理で生成したコマンドリストに従って、各コマンドを実行する。
主なファイル・関数:
execute.c
関数 do_execve(), execute_cmds() など
学習ポイント:
・フォーク (fork) とプロセスの生成
・外部コマンドの探索（PATH からの検索）
・パイプラインの実装、リダイレクトの反映
・子プロセスと親プロセスの役割の分離

## 【STEP 9：シグナルハンドリング】

目的:
ユーザーが Ctrl-C や Ctrl-\ などを入力したときに、シェルが適切に反応できるようにする。
主なファイル・関数:
signals.c
シグナルハンドラ関数（sigint_handler(), sigquit_handler()）および setup_signal_handlers()
学習ポイント:
・シグナルの種類とその処理方法
・対話型シェル特有のシグナル（readline との連携など）

## 【STEP 10：メインループの統合と最終調整】

目的:
上記の各機能を統合し、ユーザーからの入力取得、パース、実行、エラーハンドリング、環境のクリーンアップなどを一連のループとして実装する。
主なファイル・関数:
main.c
関数 minishell_loop()（初期化、ループ内での各処理の呼び出し、終了処理）
学習ポイント:
・全体のフローの確認と、各処理間のデータの受け渡し
・プログラム終了時のリソース解放（動的確保メモリのfreeなど）